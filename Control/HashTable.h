/*-------Generic Hash Table Handler-------
*	- Generic Hash Table capable to handle simple and structured/class types, provided a linked list model ('Node' or 'NodePointed')
*
*
*	Moon Wiz Studios (c) - 30/03/2016
*	by: Ramon Darwich de Menezes
*
*	
*	YOU MAY NOT use this file for commercial purposes without permission from this file creator OR Moon Wiz Studios
*	YOU MAY use it in any project of your own or edit this file, given the proper credits to Moon Wiz Studios
*   This notice MAY NOT be removed nor altered from any source distribution
*
*	Version 0.87
*/


#ifndef _H_MWHTABLE
#define _H_MWHTABLE
#include "NodeHandler.h"
#include <string.h>

#define HASH_DEBUG

enum HasherType
{
	MWHT_HASH_BY_BIT,				//Index will be generated by the bits set on the given key (useful for generic data)
	MWHT_HASH_BY_BYTE,				//Index will be generated by the byte sum on the given key (useful for strings)
	MWHT_HASH_BY_BITBYTE,			//Index will be generated by the bits set + byte sum on the given key
	MWHT_HASH_BY_ALPHA_ORDER		//Index will be generated by the first character of the given key, lower or uppercase (WILL FORCE THE TABLE TO HAVE 36 SLOTS: One for each letter and number, and another for non number/letter characters)
};


template <class DataType, class CoreNode>
//Holds the full address of an item in a Hash Table. Contains the Index of the hash, the depth of the item (if in a node) and that node info (next and previous)
struct HashItemAddress
{
	const uint32 Index = 0;
	const uint32 NodeDepth = 0;
	const CoreNode *NodePos = nullptr;

	HashItemAddress() { };
	HashItemAddress(uint32 Idx, uint32 Dpt, CoreNode *Nde) : Index(Idx), NodeDepth(Dpt), NodePos(Nde) { };
};

//Base of the Hash Table Library. All derivations MUST inherit this one. Data destruction by the base destructor is only a FAILSAFE
template <class DataType, class CoreNode>
class HashTableBase
{
protected:
	const uint32 HashSlots;
	CoreNode **Data;

	//Function pointer to our defined hasher
	uint32(HashTableBase::*Hasher)(const void*, const uint32) = nullptr;
	//We could also make a typedef(ed) function pointer to our Hasher that would work exactly the same as above:
	//	typedef uint32 (HashTable::*UniversalHasher)(const void*, const uint32);
	//	UniversalHasher Hasher = nullptr;

	//TODO: Pass parameters as reference
	//TODO: Function pointer (assigned at construction time) for diferent hash functions

	//These should NOT be called by any function, only the 'Indexer()' through the function pointer 'Hasher'
	uint32 HasherByte(const void* KeySrc, const uint32 ByteSize)
	{
		uint32 Index = 0;
		uint8 *RawData = nullptr;
		RawData = new uint8[ByteSize];
		memcpy(RawData, &KeySrc, ByteSize);

		for (int i = 0; i < ByteSize; i++)
		{
			Index += RawData[i];
		}
		delete[] RawData;
		RawData = nullptr;
		return Index % HashSlots;
	}
	uint32 HasherBit(const void* KeySrc, const uint32 ByteSize)
	{
		uint32 Index = 0;
		uint8 *RawData = nullptr;
		RawData = new uint8[ByteSize];
		memcpy(RawData, &KeySrc, ByteSize);

		for (int i = 0; i < ByteSize; i++)
		{
			for (int j = 0; j < 8; j++)
			{
				if (BitOperations::IsBitSet<char>(RawData[i], j))
				{
					Index++;
				}
			}
		}
		delete[] RawData;
		RawData = nullptr;
		return Index % HashSlots;
	}
	uint32 HasherBitByte(const void* KeySrc, const uint32 ByteSize)
	{
		uint32 Index = 0;
		uint8 *RawData = nullptr;
		RawData = new uint8[ByteSize];
		memcpy(RawData, &KeySrc, ByteSize);

		for (int i = 0; i < ByteSize; i++)
		{
			for (int j = 0; j < 8; j++)
			{
				if (BitOperations::IsBitSet<char>(RawData[i], j))
				{
					Index++;
				}
			}
			Index += RawData[i];
		}
		delete[] RawData;
		RawData = nullptr;
		return Index % HashSlots;
	}

	//Special Hashers --------------------------------------------------------------------------------
	uint32 HasherAlpha(const void* KeySrc, const uint32 ByteSize)
	{
		//In this particular case, we will discard the bytesize, since we will only use the 'KeySrc'. This pattern is only to use the 'Hasher' function pointer
		//In this Hash: these are the index order:
		//[0] ~ [9]		-> Numbers 0 ~ 9
		//[10] ~ [34]	-> Letters A/a ~ Z/z
		//[35]			-> Others
		//TIP:	In ASCII, these are the offset for theses characters:
		//Numbers: 48
		//Letters (uppercase): 65 (but since letters begin from [10] ~ [34], this offset will be 55
		//Letters (lowercase): 97 (and this, 87)
		char Conv = *((char*)KeySrc);
		//Checking if valid:
		if (Conv >= '0' && Conv <= '9')		//It's a number?
		{
			return Conv - 48;
		}
		else if (Conv >= 'A' && Conv <= 'Z')	//It's a uppercase letter?
		{
			return Conv - 55;
		}
		else if (Conv >= 'a' && Conv <= 'z')	//It's a lowercase letter?
		{
			return Conv - 87;
		}
		else											//It's a non-number/letter character!
		{
			return 35;
		}
	}

	//Call the defined hasher function and assign an index for it
	uint32 Indexer(const void* KeySrc, const uint32 ByteSize)
	{
		return (this->*Hasher)(KeySrc, ByteSize);
	}
	//Used when the table is of type 'MWHT_HASH_BY_ALPHA_ORDER'
	uint32 Indexer(const char CharTable)
	{
		if (CharTable >= '0' && CharTable <= '9')		//It's a number?
		{
			return CharTable - 48;
		}
		else if (CharTable >= 'A' && CharTable <= 'Z')	//It's a uppercase letter?
		{
			return CharTable - 55;
		}
		else if (CharTable >= 'a' && CharTable <= 'z')	//It's a lowercase letter?
		{
			return CharTable - 87;
		}
		else											//It's a non-number/letter character!
		{
			return 35;
		}
	}

	//Deallocate memory the same way a destructor would. Used like this, so we can inherit this method across all derivations easily
	void TableDestructor(void)
	{
		CoreNode *Swapper = nullptr;
		if (Data != nullptr)	//Failsafe
		{
			for (int i = 0; i < HashSlots; i++)
			{
				while (Data[i])
				{
					Swapper = Data[i]->getNext();
					Data[i]->deleteThisNode();
					Data[i] = Swapper;
				}
				Data[i] = nullptr;
			}
			delete[] Data;	//Deleting the array of pointers
			Data = nullptr;
		}
	}

public:
	//Default Constructor and Destructor
	HashTableBase(int Slots, HasherType HasherType) :
		HashSlots(
			Slots <= 0 ? 1 :
			HasherType == MWHT_HASH_BY_ALPHA_ORDER ? 36 : Slots
		) 
	{
		Data = new CoreNode*[HashSlots]; 
		for (int i = 0; i < HashSlots; i++)
		{
			Data[i] = nullptr;
		}
		switch (HasherType)
		{
		case MWHT_HASH_BY_BIT:
			Hasher = &HashTableBase::HasherBit;
			break;
		case MWHT_HASH_BY_BYTE:
			Hasher = &HashTableBase::HasherByte;
			break;
		case MWHT_HASH_BY_BITBYTE:
			Hasher = &HashTableBase::HasherBitByte;
			break;
		case MWHT_HASH_BY_ALPHA_ORDER:
			Hasher = &HashTableBase::HasherAlpha;
			break;
		}
	};
	~HashTableBase()
	{ 
		TableDestructor();
	}

	//Uses the whole 'src' both as a key and data to be inserted
	virtual void insertData(DataType &DataToInsert)
	{
		uint32 Index = Indexer(&DataToInsert, sizeof(DataType));
		if (Data[Index])	//The slot is not pointing to a null position. This means it's occupied
		{
			//Since 'Data' is a linked list, we can simply add a node after it
			Data[Index]->addNode(Data[Index], DataToInsert);
		}
		else
		{
			Data[Index] = new CoreNode;
			Data[Index]->setData(DataToInsert);
		}
	}
	//Uses a given 'Key' as a key and insert 'DataToInsert', deducting that 'Key' is of type 'DataType', using it's size to compute the key
	virtual void insertData(DataType &DataToInsert, const void* Key)
	{
		uint32 Index = Indexer(Key, sizeof(DataType));
		if (Data[Index])
		{
			Data[Index]->addNode(Data[Index], DataToInsert);
		}
		else
		{
			Data[Index] = new CoreNode;
			Data[Index]->setData(DataToInsert);
		}
	}
	//Uses a given 'Key' as a key, insert 'DataToInsert' and requires a 'ByteSize' to the actual size of 'Key'. Use this if the key given isn't of type 'DataType'
	virtual void insertData(DataType &DataToInsert, const void* Key, uint32 ByteSize)
	{
		uint32 Index = Indexer(Key, ByteSize);
		if (Data[Index])
		{
			Data[Index]->addNode(Data[Index], DataToInsert);
		}
		else
		{
			Data[Index] = new CoreNode;
			Data[Index]->setData(DataToInsert);
		}
	}
	virtual void insertDataAt(DataType &DataToInsert, uint32 Index)
	{
		if (Index < HashSlots)
		{
			if (Data[Index])
			{
				Data[Index]->addNode(Data[Index], DataToInsert);
			}
			else
			{
				Data[Index] = new CoreNode;
				Data[Index]->setData(DataToInsert);
			}
		}
	}

	uint32 getIndex(void* Key, const uint32 ByteSize)
	{
		return Indexer(Key, ByteSize);
	}
	uint32 getSlotsCount(void)
	{
		return HashSlots;
	}

	uint32 countEntriesSimple(void)
	{
		uint32 ValidEntries = 0;
		for (int i = 0; i < HashSlots; i++)
		{
			if (Data[i] != nullptr)
			{
				ValidEntries++;
			}
		}
		return ValidEntries;
	}
	uint32 countEntriesFull(void)
	{
		uint32 ValidEntries = 0;
		for (int i = 0; i < HashSlots; i++)
		{
			if (Data[i] != nullptr)
			{
				if (Data[i]->countChainLengthFrom(Data[i]) > 1)
				{
					CoreNode *Checker = Data[i];
					while (Checker != nullptr)
					{
						ValidEntries++;
						Checker = Checker->getNext();
					}
				}
				else
				{
					ValidEntries++;
				}
			}
		}
		return ValidEntries;
	}
	double computeClusterization(void)
	{
		//Basic percentage of clusterization (higher means inefficient hasher function distribution)
		uint32 OcupSlots = countEntriesSimple();
		uint32 OcupSlotsFull = countEntriesFull();
		if (OcupSlotsFull <= HashSlots)	//We have enough slots to hold all entries
		{
			if (OcupSlots < OcupSlotsFull)	//If we have more than one entry in the same index, even though we have enough room to save it elsewhere
			{
				return 1 - ((double)(HashSlots - OcupSlots) / HashSlots);
			}
			else							//We are simply full ' -'
			{
				return 0;
			}
		}
		else									//We are over capacity!!
		{
			return (double)(HashSlots - OcupSlots) / HashSlots;
		}
	}
	double computeHasherDistributionFaults(uint32 ErrorMargin)
	{
		//Percentage of Distribution Faults (higher means inefficient hasher function distribution)
		uint32 Entries = countEntriesFull();
		uint32 DistributionRate = Entries / HashSlots;	//This translates to "How many nodes should every entry have?"
		double IrregularEntries = 0;
		if (!DistributionRate)							//It cannot be 0, since at worst case, every entry should have at least 1 node (itself)
		{
			DistributionRate = 1;
		}
		for (uint32 i = 0, ChainLength; i < HashSlots; i++)
		{
			if (Data[i] != nullptr)
			{
				ChainLength = Data[i]->countChainLengthFrom(Data[i]);
				if (ChainLength - ErrorMargin > DistributionRate || ChainLength + ErrorMargin < DistributionRate)
				{
					IrregularEntries++;
				}
			}
		}
		return IrregularEntries / countEntriesSimple();
	}

	void clearEntry(uint32 Index, uint32 Depth)
	{
		if (Index < HashSlots)
		{
			if (Data[Index])
			{
				Data[Index]->getNode(Depth)->deleteThisNode();
			}
		}
	}
	virtual void clearIndex(uint32 Index)
	{
		if (Index < HashSlots)
		{
			if (Data[Index])
			{
				Data[Index]->deleteThisChain();	//Since there is no more node here, we don't need (actually we CANNOT) call "delete Data[Index]"
				Data[Index] = nullptr;
			}
		}
	}
	//Same as 'destroyTable', but without calling 'delete'
	void clearAll(void)
	{
		for (int i = 0; i < HashSlots; i++)
		{
			if (Data[i] != nullptr)
			{
				clearIndex(i);
			}
		}
	}
	//Note: This method calls the destructor for all of it's internal data storage (structures) (faster, but can cause stack overflows on table with alot of nodes)
	void destroyTable(void)
	{
		TableDestructor();
	}

	HashItemAddress<DataType, CoreNode>& findAddressFrom(DataType* Target)
	{
		CoreNode *Checker = nullptr;
		if (Target)	//'Target' exists
		{
			for (int i = 0; i < HashSlots; i++)
			{
				if (Data[i])	//'Data[i]' exists
				{
					if (&Data[i]->getData() == Target)
					{
						return HashItemAddress<DataType, CoreNode>(i, 0, nullptr);
					}
					else if (Data[i]->getNext())
					{
						Checker = Data[i]->getNext();
						do{
							if (&Checker->getData() == Target)
							{
								return HashItemAddress<DataType, CoreNode>(i, CoreNode::countChainLengthBetween(Data[i], Checker), Checker);
							}
							Checker = Checker->getNext();
						} while (Checker != nullptr);
					}
				}
			}
		}
		return HashItemAddress<DataType, CoreNode>();
	}
	
	//Virtual Functions
	virtual DataType* getDataFrom(void* Key, const uint32 ByteSize) = 0;
	virtual DataType* getDataFrom(void* Key, const uint32 ByteSize, uint32 NodeDepth) = 0;
	virtual DataType* getDataAt(uint32 Index) = 0;
	virtual DataType* getDataAt(uint32 Index, uint32 NodeDepth) = 0;

	//'findData' functions MUST be defined by each derivation

#ifdef HASH_DEBUG
	void d_displayContents(char* DataTypeName)
	{
		uint32 ErrorMargin = 1;
		std::cout << "------------------ HASH TABLE CONTENTS ------------------" << std::endl;
		std::cout << "[HASH] " << HashSlots << " Slots for data '" << DataTypeName << "' with size of " << sizeof(DataType) << "B each with a total of " << sizeof(CoreNode) << "B (Noded)" << std::endl;
		std::cout << "[HASH] Currently have " << this->countEntriesSimple() << "/" << HashSlots << " (" << HashSlots - this->countEntriesSimple() << " Free) entries in use (" << this->countEntriesFull() << " entries with nodes) using " << sizeof(CoreNode) * this->countEntriesFull() << "B(" << (sizeof(CoreNode) * this->countEntriesFull()) / 1024 << "KB)" << std::endl;
		std::cout << "[HASH] Theorical Clusterization: " << this->computeClusterization() << " (" << this->computeClusterization() * 100 << "%)" << std::endl;
		std::cout << "[HASH] Theorical Distribution Faults: " << this->computeHasherDistributionFaults(ErrorMargin) << " (" << this->computeHasherDistributionFaults(ErrorMargin) * 100 << "%) with Error Margin of " << ErrorMargin << std::endl;
		for (int i = 0; i < HashSlots; i++)
		{
			std::cout << " *[" << i << "] - ";
			if (Data[i] == nullptr)
			{
				std::cout << "<|> NULL <|>";
			}
			else
			{
				int ChainLength = Data[i]->countChainLengthFrom(Data[i]);
				if (ChainLength == 1)
				{
					std::cout << "(Single Entry)";
				}
				else
				{
					std::cout << "{Nested Entry} (" << ChainLength << " Nodes)";
				}
			}
			std::cout << std::endl;
		}
		if (HashSlots >= 50)
		{
			std::cout << "------------------ END OF ENTRIES ------------------" << std::endl;
			std::cout << "[HASH] " << HashSlots << " Slots for data '" << DataTypeName << "' with size of " << sizeof(DataType) << "B each with a total of " << sizeof(CoreNode) << "B (Noded)" << std::endl;
			std::cout << "[HASH] Currently have " << countEntriesSimple() << "/" << HashSlots << " (" << HashSlots - countEntriesSimple() << " Free) entries in use (" << countEntriesFull() << " entries with nodes) using " << sizeof(CoreNode) * countEntriesFull() << "B(" << (sizeof(CoreNode) * countEntriesFull()) / 1024 << "KB)" << std::endl;
			std::cout << "[HASH] Clusterization: " << this->computeClusterization() << " (" << this->computeClusterization() * 100 << "%) " << std::endl;
			std::cout << "[HASH] Distribution Faults: " << this->computeHasherDistributionFaults(ErrorMargin) << " (" << this->computeHasherDistributionFaults(ErrorMargin) * 100 << "%) with Error Margin of " << ErrorMargin << std::endl;
		}
		std::cout << "------------------ HASH TABLE DEBG END ------------------" << std::endl;
	}
	void d_displayContentsDetailed(char* DataTypeName)
	{
		uint32 ErrorMargin = 1;
		std::cout << "------------------ HASH TABLE CONTENTS [+] ------------------" << std::endl;
		std::cout << "[HASH] " << HashSlots << " Slots for data '" << DataTypeName << "' with size of " << sizeof(DataType) << "B each with a total of " << sizeof(CoreNode) << "B (Noded)" << std::endl;
		std::cout << "[HASH] Currently have " << countEntriesSimple() << "/" << HashSlots << " (" << HashSlots - countEntriesSimple() << " Free) entries in use (" << countEntriesFull() << " entries with nodes) using " << sizeof(CoreNode) * countEntriesFull() << "B(" << (sizeof(CoreNode) * countEntriesFull()) / 1024 << "KB)" << std::endl;
		std::cout << "[HASH] Theorical Clusterization: " << computeClusterization() << " (" << computeClusterization() * 100 << "%)" << std::endl;
		std::cout << "[HASH] Theorical Distribution Faults: " << computeHasherDistributionFaults(ErrorMargin) << " (" << computeHasherDistributionFaults(ErrorMargin) * 100 << "%) with Error Margin of " << ErrorMargin << std::endl;
		std::cout << "(P) -> Previous CoreNode | (C) -> Current CoreNode | (N) -> Next CoreNode" << std::endl;
		for (int i = 0; i < HashSlots; i++)
		{
			std::cout << " *[" << i << "] - ";
			if (Data[i] == nullptr)
			{
				std::cout << "<|> NULL <|>"  << std::endl;
			}
			else
			{
				int ChainLength = Data[i]->countChainLengthFrom(Data[i]);
				if (ChainLength == 1)
				{
					std::cout << "(Single Entry) [" << Data[i]->getClassDataPointer() << "]" << std::endl;
				}
				else
				{
					std::cout << "{Nested Entry} (" << ChainLength << " Nodes)" << std::endl;
					CoreNode *Checker = Data[i];
					int NodeDepth = 0;
					while (Checker != nullptr)
					{
						std::cout << "\t>[" << i << "." << NodeDepth << "] - (P)[" << Checker->getPrevious()->getClassDataPointer() << "] (C)[" << Checker->getClassDataPointer() << "] (N)[" << Checker->getNext()->getClassDataPointer() << "]" << std::endl;
						Checker = Checker->getNext();
						NodeDepth++;
					}
				}
			}
		}
		if (countEntriesFull() >= 50)	//To ease data analysis when the Hash Table is too big
		{
			std::cout << "------------------ END OF ENTRIES ------------------" << std::endl;
			std::cout << "[HASH] " << HashSlots << " Slots for data '" << DataTypeName << "' with size of " << sizeof(DataType) << "B each with a total of " << sizeof(CoreNode) << "B (Noded)" << std::endl;
			std::cout << "[HASH] Currently have " << countEntriesSimple() << "/" << HashSlots << " (" << HashSlots - countEntriesSimple() << " Free) entries in use (" << countEntriesFull() << " entries with nodes) using " << sizeof(CoreNode) * countEntriesFull() << "B(" << (sizeof(CoreNode) * countEntriesFull()) / 1024 << "KB)" << std::endl;
			std::cout << "[HASH] Clusterization: " << this->computeClusterization() << " (" << this->computeClusterization() * 100 << "%) " << std::endl;
			std::cout << "[HASH] Distribution Faults: " << this->computeHasherDistributionFaults(ErrorMargin) << " (" << this->computeHasherDistributionFaults(ErrorMargin) * 100 << "%) with Error Margin of " << ErrorMargin << std::endl;
		}
		std::cout << "------------------ HASH TABLE DEBG END [+] ------------------" << std::endl;
	}
	void d_displayContentsDetailed(char* DataTypeName, char** IndexLabel, uint32 Labels)
	{
		uint32 ErrorMargin = 1;
		std::cout << "------------------ HASH TABLE CONTENTS [+] ------------------" << std::endl;
		std::cout << "[HASH] " << HashSlots << " Slots for data '" << DataTypeName << "' with size of " << sizeof(DataType) << "B each with a total of " << sizeof(CoreNode) << "B (Noded)" << std::endl;
		std::cout << "[HASH] Currently have " << countEntriesSimple() << "/" << HashSlots << " (" << HashSlots - countEntriesSimple() << " Free) entries in use (" << countEntriesFull() << " entries with nodes) using " << sizeof(CoreNode) * countEntriesFull() << "B(" << (sizeof(CoreNode) * countEntriesFull()) / 1024 << "KB)" << std::endl;
		std::cout << "[HASH] Theorical Clusterization: " << computeClusterization() << " (" << computeClusterization() * 100 << "%)" << std::endl;
		std::cout << "[HASH] Theorical Distribution Faults: " << computeHasherDistributionFaults(ErrorMargin) << " (" << computeHasherDistributionFaults(ErrorMargin) * 100 << "%) with Error Margin of " << ErrorMargin << std::endl;
		std::cout << "(P) -> Previous CoreNode | (C) -> Current CoreNode | (N) -> Next CoreNode" << std::endl;
		for (int i = 0, lbl = 0; i < HashSlots; i++)
		{
			std::cout << " *[" << i << "] - ";
			if (Data[i] == nullptr)
			{
				std::cout << "<|> NULL <|>" << std::endl;
			}
			else
			{
				int ChainLength = Data[i]->countChainLengthFrom(Data[i]);
				if (ChainLength == 1)
				{
					std::cout << "(Single Entry) [" << Data[i]->getClassDataPointer() << "] | [" << IndexLabel[lbl] << "]" << std::endl;
				}
				else
				{
					std::cout << "{Nested Entry} (" << ChainLength << " Nodes) | [" << IndexLabel[lbl] << "]" << std::endl;
					CoreNode *Checker = Data[i];
					int NodeDepth = 0;
					while (Checker != nullptr)
					{
						std::cout << "\t>[" << i << "." << NodeDepth << "] - (P)[" << Checker->getPrevious()->getClassDataPointer() << "] (C)[" << Checker->getClassDataPointer() << "] (N)[" << Checker->getNext()->getClassDataPointer() << "]" << std::endl;
						Checker = Checker->getNext();
						NodeDepth++;
					}
				}
			}
			if (i < Labels)
			{
				lbl++;
			}
		}
		if (countEntriesFull() >= 50)	//To ease data analysis when the Hash Table is too big
		{
			std::cout << "------------------ END OF ENTRIES ------------------" << std::endl;
			std::cout << "[HASH] " << HashSlots << " Slots for data '" << DataTypeName << "' with size of " << sizeof(DataType) << "B each with a total of " << sizeof(CoreNode) << "B (Noded)" << std::endl;
			std::cout << "[HASH] Currently have " << countEntriesSimple() << "/" << HashSlots << " (" << HashSlots - countEntriesSimple() << " Free) entries in use (" << countEntriesFull() << " entries with nodes) using " << sizeof(CoreNode) * countEntriesFull() << "B(" << (sizeof(CoreNode) * countEntriesFull()) / 1024 << "KB)" << std::endl;
			std::cout << "[HASH] Clusterization: " << this->computeClusterization() << " (" << this->computeClusterization() * 100 << "%) " << std::endl;
			std::cout << "[HASH] Distribution Faults: " << this->computeHasherDistributionFaults(ErrorMargin) << " (" << this->computeHasherDistributionFaults(ErrorMargin) * 100 << "%) with Error Margin of " << ErrorMargin << std::endl;
		}
		std::cout << "------------------ HASH TABLE DEBG END [+] ------------------" << std::endl;
	}
	void d_displayContentsDetailed(char* DataTypeName, char* EntryName)
	{
		uint32 ErrorMargin = 1;
		std::cout << "------------------ HASH TABLE CONTENTS [+] ------------------" << std::endl;
		std::cout << "[HASH] " << HashSlots << " Slots for data '" << DataTypeName <<"' with size of " << sizeof(DataType) << "B each with a total of " << sizeof(CoreNode) << "B (Noded)" << std::endl;
		std::cout << "[HASH] Currently have " << countEntriesSimple() << "/" << HashSlots << " (" << HashSlots - countEntriesSimple() << " Free) entries in use (" << countEntriesFull() << " entries with nodes) using " << sizeof(CoreNode) * countEntriesFull() << "B(" << (sizeof(CoreNode) * countEntriesFull()) / 1024 << "KB)" << std::endl;
		std::cout << "[HASH] Theorical Clusterization: " << computeClusterization() << " (" << computeClusterization() * 100 << "%)" << std::endl;
		std::cout << "[HASH] Theorical Distribution Faults: " << computeHasherDistributionFaults(ErrorMargin) << " (" << computeHasherDistributionFaults(ErrorMargin) * 100 << "%) with Error Margin of " << ErrorMargin << std::endl;
		std::cout << "(P) -> Previous CoreNode | (C) -> Current CoreNode | (N) -> Next CoreNode" << std::endl;
		for (int i = 0; i < HashSlots; i++)
		{
			std::cout << " *[" << i << "] - ";
			if (Data[i] == nullptr)
			{
				std::cout << "<|> NULL <|>" << std::endl;
			}
			else
			{
				int ChainLength = Data[i]->countChainLengthFrom(Data[i]);
				if (ChainLength == 1)
				{
					std::cout << "(Single Entry) [" << Data[i]->getClassDataPointer() << "]" << std::endl;
					if (Hasher == &HashTableBase::HasherAlpha)	//If true, then we are in an alphabhetic Table
					{
						char* Printer = nullptr;
						memcpy(Printer, Data[i]->getClassDataPointer(), sizeof(DataType));
						std::cout << "\t*[" << EntryName << "] -> [" << Printer << "]" << std::endl;
					}
					else
					{
						std::cout << "\t*[" << EntryName << "] -> [" << Data[i]->getData() << "]" << std::endl;
					}
				}
				else
				{
					std::cout << "{Nested Entry} (" << ChainLength << " Nodes)" << std::endl;
					CoreNode *Checker = Data[i];
					int NodeDepth = 0;
					while (Checker != nullptr)
					{
						std::cout << "\t>[" << i << "." << NodeDepth << "] - (P)[" << Checker->getPrevious()->getClassDataPointer() << "] (C)[" << Checker->getClassDataPointer() << "] (N)[" << Checker->getNext()->getClassDataPointer() << "]" << std::endl;
						if (Hasher == &HashTableBase::HasherAlpha)	//If true, then we are in an alphabhetic Table
						{
							char* Printer = nullptr;
							memcpy(Printer, Data[i]->getClassDataPointer(), sizeof(DataType));
							std::cout << "\t\t*[" << EntryName << "] -> [" << Printer << "]" << std::endl;
						}
						else
						{
							std::cout << "\t\t*[" << EntryName << "] -> [" << Data[i]->getData() << "]" << std::endl;
						}
						Checker = Checker->getNext();
						NodeDepth++;
					}
				}
			}
		}
		if (countEntriesFull() >= 50)
		{
			std::cout << "------------------ END OF ENTRIES ------------------" << std::endl;
			std::cout << "[HASH] " << HashSlots << " Slots for data '" << DataTypeName << "' with size of " << sizeof(DataType) << "B each with a total of " << sizeof(CoreNode) << "B (Noded)" << std::endl;
			std::cout << "[HASH] Currently have " << countEntriesSimple() << "/" << HashSlots << " (" << HashSlots - countEntriesSimple() << " Free) entries in use (" << countEntriesFull() << " entries with nodes) using " << sizeof(CoreNode) * countEntriesFull() << "B(" << (sizeof(CoreNode) * countEntriesFull()) / 1024 << "KB)" << std::endl;
			std::cout << "[HASH] Clusterization: " << computeClusterization() << " (" << computeClusterization() * 100 << "%) " << std::endl;
			std::cout << "[HASH] Distribution Faults: " << computeHasherDistributionFaults(ErrorMargin) << " (" << computeHasherDistributionFaults(ErrorMargin) * 100 << "%) with Error Margin of " << ErrorMargin << std::endl;
		}
		std::cout << "------------------ HASH TABLE DEBG END [+] ------------------" << std::endl;
	}
	void d_displayContentsDetailedString(char* DataTypeName, char* EntryName)
	{
		uint32 ErrorMargin = 1;
		char* Printer = new char[sizeof(DataType)];
		std::cout << "------------------ HASH TABLE CONTENTS [+] ------------------" << std::endl;
		std::cout << "[HASH] " << HashSlots << " Slots for data '" << DataTypeName << "' with size of " << sizeof(DataType) << "B each with a total of " << sizeof(CoreNode) << "B (Noded)" << std::endl;
		std::cout << "[HASH] Currently have " << countEntriesSimple() << "/" << HashSlots << " (" << HashSlots - countEntriesSimple() << " Free) entries in use (" << countEntriesFull() << " entries with nodes) using " << sizeof(CoreNode) * countEntriesFull() << "B(" << (sizeof(CoreNode) * countEntriesFull()) / 1024 << "KB)" << std::endl;
		std::cout << "[HASH] Theorical Clusterization: " << computeClusterization() << " (" << computeClusterization() * 100 << "%)" << std::endl;
		std::cout << "[HASH] Theorical Distribution Faults: " << computeHasherDistributionFaults(ErrorMargin) << " (" << computeHasherDistributionFaults(ErrorMargin) * 100 << "%) with Error Margin of " << ErrorMargin << std::endl;
		std::cout << "(P) -> Previous CoreNode | (C) -> Current CoreNode | (N) -> Next CoreNode" << std::endl;
		for (int i = 0; i < HashSlots; i++)
		{
			std::cout << " *[" << i << "] - ";
			if (Data[i] == nullptr)
			{
				std::cout << "<|> NULL <|>" << std::endl;
			}
			else
			{
				int ChainLength = Data[i]->countChainLengthFrom(Data[i]);
				if (ChainLength == 1)
				{
					std::cout << "(Single Entry) [" << Data[i]->getClassDataPointer() << "]" << std::endl;
					if (Hasher == &HashTableBase::HasherAlpha)	//If true, then we are in an alphabhetic Table
					{
						memcpy(Printer, Data[i]->getClassDataPointer(), sizeof(DataType));
						std::cout << "\t*[" << EntryName << "] -> ['" << Printer << "']" << std::endl;
					}
					else
					{
						std::cout << "\t*[" << EntryName << "] -> [(!) INVALID TYPE (!)]" << std::endl;
					}
				}
				else
				{
					std::cout << "{Nested Entry} (" << ChainLength << " Nodes)" << std::endl;
					CoreNode *Checker = Data[i];
					int NodeDepth = 0;
					while (Checker != nullptr)
					{
						std::cout << "\t>[" << i << "." << NodeDepth << "] - (P)[" << Checker->getPrevious()->getClassDataPointer() << "] (C)[" << Checker->getClassDataPointer() << "] (N)[" << Checker->getNext()->getClassDataPointer() << "]" << std::endl;
						if (Hasher == &HashTableBase::HasherAlpha)	//If true, then we are in an alphabhetic Table
						{
							memcpy(Printer, Checker->getClassDataPointer(), sizeof(DataType));
							std::cout << "\t\t*[" << EntryName << "] -> ['" << Printer << "']" << std::endl;
						}
						else
						{
							std::cout << "\t\t*[" << EntryName << "] -> [! INVALID TYPE !]" << std::endl;
						}
						Checker = Checker->getNext();
						NodeDepth++;
					}
				}
			}
		}
		if (countEntriesFull() >= 50)
		{
			std::cout << "------------------ END OF ENTRIES ------------------" << std::endl;
			std::cout << "[HASH] " << HashSlots << " Slots for data '" << DataTypeName << "' with size of " << sizeof(DataType) << "B each with a total of " << sizeof(CoreNode) << "B (Noded)" << std::endl;
			std::cout << "[HASH] Currently have " << countEntriesSimple() << "/" << HashSlots << " (" << HashSlots - countEntriesSimple() << " Free) entries in use (" << countEntriesFull() << " entries with nodes) using " << sizeof(CoreNode) * countEntriesFull() << "B(" << (sizeof(CoreNode) * countEntriesFull()) / 1024 << "KB)" << std::endl;
			std::cout << "[HASH] Clusterization: " << computeClusterization() << " (" << computeClusterization() * 100 << "%) " << std::endl;
			std::cout << "[HASH] Distribution Faults: " << computeHasherDistributionFaults(ErrorMargin) << " (" << computeHasherDistributionFaults(ErrorMargin) * 100 << "%) with Error Margin of " << ErrorMargin << std::endl;
		}
		std::cout << "------------------ HASH TABLE DEBG END [+] ------------------" << std::endl;
		delete[] Printer;
		Printer = nullptr;
	}
#endif

};

template <class DataType, class CoreNode>
//Simple Hash Table that handles data primitives (int/float/char/string). For a Class/Struct handling table, use 'ClassHashTable'
// (!!) Linked List model required ('CoreNode')
//	-> Available Linked List models: 'Node' (Internal List data is constructed) OR 'NodePointed' (Internal List data is a pointer to data (don't construct))
class SimpleHashTable : public HashTableBase<DataType, CoreNode>
{
public:
	SimpleHashTable(int Slots, HasherType Hasher) : HashTableBase<DataType, CoreNode>(Slots, Hasher) { };
	~SimpleHashTable()
	{
		TableDestructor();
	}

	DataType* getDataFrom(void* Key, const uint32 ByteSize)
	{
		return &Data[Indexer(Key, ByteSize)]->getData();
	}
	DataType* getDataFrom(void* Key, const uint32 ByteSize, uint32 NodeDepth)
	{
		return &Data[Indexer(Key, ByteSize)]->getNode(NodeDepth)->getData();
	}
	DataType* getDataAt(uint32 Index)
	{
		return &Data[Index]->getData();
	}
	DataType* getDataAt(uint32 Index, uint32 NodeDepth)
	{
		return &Data[Index]->getNode(NodeDepth)->getData();
	}

	//For Simple plain data
	template <class Type>
	DataType* findData(void* Key, const uint32 ByteSize, Type Value)
	{
		uint32 Index = Indexer(Key, ByteSize);
		//Now we search if 'Value' is equal to the value pointed by the member-pointer, or, the value of that member itself. Read this as:
		//The value of 'Value' IS equal to the value from the MEMBER pointed by 'Member', from the class GET from the NodeHandler 'getClassDataAddress()', which node is pointed by Data[i]? Phew, that's pretty confusing
		if (Data[Index] == nullptr)
		{
			return nullptr;
		}
		else if (Data[Index]->getData() == Value)
		{
			return &Data[Index]->getClassDataAddress();
		}
		else if (Data[Index]->getNext() != nullptr)	//Searching for it trough the linked list nodes
		{
			CoreNode *Checker = Data[Index]->getNext();
			do{
				if (Checker->getData() == Value)
				{
					return &Checker->getClassDataAddress();
				}
				Checker = Checker->getNext();
			} while (Checker != nullptr);
		}
		return nullptr;
	}
	//For characters
	DataType* findData(void* Key, char CharacterToFind)
	{
		uint32 Index = Indexer(Key, ByteSize);
		//Now we search if 'Value' is equal to the value pointed by the member-pointer, or, the value of that member itself. Read this as:
		//The value of 'Value' IS equal to the value from the MEMBER pointed by 'Member', from the class GET from the NodeHandler 'getClassDataAddress()', which node is pointed by Data[i]? Phew, that's pretty confusing
		if (Data[Index] == nullptr)
		{
			return nullptr;
		}
		else if (!memcmp(Data[Index]->getData(), CharacterToFind, 1))
		{
			return &Data[Index]->getClassDataAddress();
		}
		else if (Data[Index]->getNext() != nullptr)	//Searching for it trough the linked list nodes
		{
			CoreNode *Checker = Data[Index]->getNext();
			do{
				if (!memcmp(Checker->getData(), CharacterToFind, 1))
				{
					return &Checker->getClassDataAddress();
				}
				Checker = Checker->getNext();
			} while (Checker != nullptr);
		}
		return nullptr;
	}
	//For characters
	DataType* findData(char CharTable, char CharacterToFind)
	{
		uint32 Index = Indexer(CharTable);
		//Now we search if 'Value' is equal to the value pointed by the member-pointer, or, the value of that member itself. Read this as:
		//The value of 'Value' IS equal to the value from the MEMBER pointed by 'Member', from the class GET from the NodeHandler 'getClassDataAddress()', which node is pointed by Data[i]? Phew, that's pretty confusing
		if (Data[Index] == nullptr)
		{
			return nullptr;
		}
		else if (!memcmp((void*)(&Data[Index]->getData()), &CharacterToFind, 1))
		{
			return &Data[Index]->getClassDataAddress();
		}
		else if (Data[Index]->getNext() != nullptr)	//Searching for it trough the linked list nodes
		{
			CoreNode *Checker = Data[Index]->getNext();
			do{
				if (!memcmp((void*)(&Checker->getData()), &CharacterToFind, 1))
				{
					return &Checker->getClassDataAddress();
				}
				Checker = Checker->getNext();
			} while (Checker != nullptr);
		}
		return nullptr;
	}
	//For strings
	DataType* findData(void* Key, const uint32 ByteSize, char* TextToFind)
	{
		uint32 Index = Indexer(Key, ByteSize);
		//Now we search if 'Value' is equal to the value pointed by the member-pointer, or, the value of that member itself. Read this as:
		//The value of 'Value' IS equal to the value from the MEMBER pointed by 'Member', from the class GET from the NodeHandler 'getClassDataAddress()', which node is pointed by Data[i]? Phew, that's pretty confusing
		if (Data[Index] == nullptr)
		{
			return nullptr;
		}
		else if (!memcmp(Data[Index]->getClassDataAddress(), TextToFind, ByteSize))
		{
			return &Data[Index]->getClassDataAddress();
		}
		else if (Data[Index]->getNext() != nullptr)	//Searching for it trough the linked list nodes
		{
			CoreNode *Checker = Data[Index]->getNext();
			do{
				if (!memcmp(Checker->getClassDataAddress(), TextToFind, ByteSize))
				{
					return &Checker->getClassDataAddress();
				}
				Checker = Checker->getNext();
			} while (Checker != nullptr);
		}
		return nullptr;
	}
	//For strings
	DataType* findData(char CharTable, char* TextToFind)
	{
		uint32 Index = Indexer(CharTable);
		//Now we search if 'Value' is equal to the value pointed by the member-pointer, or, the value of that member itself. Read this as:
		//The value of 'Value' IS equal to the value from the MEMBER pointed by 'Member', from the class GET from the NodeHandler 'getClassDataAddress()', which node is pointed by Data[i]? Phew, that's pretty confusing
		if (Data[Index] == nullptr)
		{
			return nullptr;
		}
		else if (!memcmp((void*)(&Data[Index]->getData()), TextToFind, strlen(TextToFind)))
		{
			return &Data[Index]->getClassDataAddress();
		}
		else if (Data[Index]->getNext() != nullptr)	//Searching for it trough the linked list nodes
		{
			CoreNode *Checker = Data[Index]->getNext();
			do{
				if (!memcmp((void*)(&Checker->getData()), TextToFind, strlen(TextToFind)))
				{
					return &Checker->getClassDataAddress();
				}
				Checker = Checker->getNext();
			} while (Checker != nullptr);
		}
		return nullptr;
	}

	//For Simple plain data
	template <class Type>
	HashItemAddress<DataType, CoreNode>& findAddressOf(void* Key, const uint32 ByteSize, Type Value)
	{
		uint32 Index = Indexer(Key, ByteSize);
		//Now we search if 'Value' is equal to the value pointed by the member-pointer, or, the value of that member itself. Read this as:
		//The value of 'Value' IS equal to the value from the MEMBER pointed by 'Member', from the class GET from the NodeHandler 'getClassDataAddress()', which node is pointed by Data[i]? Phew, that's pretty confusing
		if (Data[Index] == nullptr)
		{
			return HashItemAddress<DataType, CoreNode>();
		}
		else if (Data[Index]->getData() == Value)
		{
			return HashItemAddress<DataType, CoreNode>(Index, 0, nullptr);
		}
		else if (Data[Index]->getNext() != nullptr)	//Searching for it trough the linked list nodes
		{
			CoreNode *Checker = Data[Index]->getNext();
			do{
				if (Checker->getData() == Value)
				{
					return HashItemAddress<DataType, CoreNode>(Index, CoreNode::countChainLengthBetween(Data[Index], Checker), Checker);
				}
				Checker = Checker->getNext();
			} while (Checker != nullptr);
		}
		return return HashItemAddress<DataType, CoreNode>();
	}
	//For characters
	HashItemAddress<DataType, CoreNode>& findAddressOf(void* Key, char CharacterToFind)
	{
		uint32 Index = Indexer(Key, ByteSize);
		//Now we search if 'Value' is equal to the value pointed by the member-pointer, or, the value of that member itself. Read this as:
		//The value of 'Value' IS equal to the value from the MEMBER pointed by 'Member', from the class GET from the NodeHandler 'getClassDataAddress()', which node is pointed by Data[i]? Phew, that's pretty confusing
		if (Data[Index] == nullptr)
		{
			return HashItemAddress<DataType, CoreNode>();
		}
		else if (!memcmp(Data[Index]->getData(), CharacterToFind, 1))
		{
			return HashItemAddress<DataType, CoreNode>(Index, 0, nullptr);
		}
		else if (Data[Index]->getNext() != nullptr)	//Searching for it trough the linked list nodes
		{
			CoreNode *Checker = Data[Index]->getNext();
			do{
				if (!memcmp(Checker->getData(), CharacterToFind, 1))
				{
					return HashItemAddress<DataType, CoreNode>(Index, CoreNode::countChainLengthBetween(Data[Index], Checker), Checker);
				}
				Checker = Checker->getNext();
			} while (Checker != nullptr);
		}
		return return HashItemAddress<DataType, CoreNode>();
	}
	//For characters
	HashItemAddress<DataType, CoreNode>& findAddressOf(char CharTable, char CharacterToFind)
	{
		uint32 Index = Indexer(CharTable);
		//Now we search if 'Value' is equal to the value pointed by the member-pointer, or, the value of that member itself. Read this as:
		//The value of 'Value' IS equal to the value from the MEMBER pointed by 'Member', from the class GET from the NodeHandler 'getClassDataAddress()', which node is pointed by Data[i]? Phew, that's pretty confusing
		if (Data[Index] == nullptr)
		{
			return HashItemAddress<DataType, CoreNode>();
		}
		else if (!memcmp((void*)(&Data[Index]->getData()), &CharacterToFind, 1))
		{
			return HashItemAddress<DataType, CoreNode>(Index, 0, nullptr);
		}
		else if (Data[Index]->getNext() != nullptr)	//Searching for it trough the linked list nodes
		{
			CoreNode *Checker = Data[Index]->getNext();
			do{
				if (!memcmp((void*)(&Checker->getData()), &CharacterToFind, 1))
				{
					return HashItemAddress<DataType, CoreNode>(Index, CoreNode::countChainLengthBetween(Data[Index], Checker), Checker);
				}
				Checker = Checker->getNext();
			} while (Checker != nullptr);
		}
		return return HashItemAddress<DataType, CoreNode>();
	}
	//For strings
	HashItemAddress<DataType, CoreNode>& findAddressOf(void* Key, const uint32 ByteSize, char* TextToFind)
	{
		uint32 Index = Indexer(Key, ByteSize);
		//Now we search if 'Value' is equal to the value pointed by the member-pointer, or, the value of that member itself. Read this as:
		//The value of 'Value' IS equal to the value from the MEMBER pointed by 'Member', from the class GET from the NodeHandler 'getClassDataAddress()', which node is pointed by Data[i]? Phew, that's pretty confusing
		if (Data[Index] == nullptr)
		{
			return HashItemAddress<DataType, CoreNode>();
		}
		else if (!memcmp(Data[Index]->getClassDataAddress(), TextToFind, ByteSize))
		{
			return HashItemAddress<DataType, CoreNode>(Index, 0, nullptr);
		}
		else if (Data[Index]->getNext() != nullptr)	//Searching for it trough the linked list nodes
		{
			CoreNode *Checker = Data[Index]->getNext();
			do{
				if (!memcmp(Checker->getClassDataAddress(), TextToFind, ByteSize))
				{
					return HashItemAddress<DataType, CoreNode>(Index, CoreNode::countChainLengthBetween(Data[Index], Checker), Checker);
				}
				Checker = Checker->getNext();
			} while (Checker != nullptr);
		}
		return return HashItemAddress<DataType, CoreNode>();
	}
	//For strings
	HashItemAddress<DataType, CoreNode>& findAddressOf(char CharTable, char* TextToFind)
	{
		uint32 Index = Indexer(CharTable);
		//Now we search if 'Value' is equal to the value pointed by the member-pointer, or, the value of that member itself. Read this as:
		//The value of 'Value' IS equal to the value from the MEMBER pointed by 'Member', from the class GET from the NodeHandler 'getClassDataAddress()', which node is pointed by Data[i]? Phew, that's pretty confusing
		if (Data[Index] == nullptr)
		{
			return HashItemAddress<DataType, CoreNode>();
		}
		else if (!memcmp((void*)(&Data[Index]->getData()), TextToFind, strlen(TextToFind)))
		{
			return HashItemAddress<DataType, CoreNode>(Index, 0, nullptr);
		}
		else if (Data[Index]->getNext() != nullptr)	//Searching for it trough the linked list nodes
		{
			CoreNode *Checker = Data[Index]->getNext();
			do{
				if (!memcmp((void*)(&Checker->getData()), TextToFind, strlen(TextToFind)))
				{
					return HashItemAddress<DataType, CoreNode>(Index, CoreNode::countChainLengthBetween(Data[Index], Checker), Checker);
				}
				Checker = Checker->getNext();
			} while (Checker != nullptr);
		}
		return HashItemAddress<DataType, CoreNode>();
	}

};

template <class DataType, class CoreNode>
//Same as 'SimpleHashTable' but designed to handles class and structures as it base and source data. 
// (!!) Linked List model required ('CoreNode')
//	-> Available Linked List models: 'Node' (Internal List data is constructed) OR 'NodePointed' (Internal List data is a pointer to data (don't construct))
class ClassHashTable : public HashTableBase<DataType, CoreNode>
{
protected:
	template <class Type>
	DataType* searchAll(const uint32 Index, const Type DataType::*Member, Type Value)
	{
		CoreNode *Checker = nullptr;
		//Searching both ways, so we can find a result faster
		for (int i = Index, j = Index; i < HashSlots; i++)
		{
			if (Data[i])	//Data[i] is NOT NULL
			{
				if (Data[i]->getData().*Member == Value)	//If the first entry have the value we are searching for, then we stop here
				{
					return &Data[i]->getData();
				}
				else if (Data[i]->getNext())	//If not, and the entry contains nodes, we search trough them
				{
					Checker = Data[i]->getNext();
					do{
						if (Checker->getData().*Member == Value)
						{
							return &Checker->getData();
						}
						Checker = Checker->getNext();
					} while (Checker != nullptr);
				}
			}
			if (Data[j])
			{
				if (Data[j]->getData().*Member == Value)
				{
					return &Data[j]->getData();
				}
				else if (Data[j]->getNext())
				{
					Checker = Data[j]->getNext();
					do{
						if (Checker->getData().*Member == Value)
						{
							return &Checker->getData();
						}
						Checker = Checker->getNext();
					} while (Checker != nullptr);
				}
			}
			j--;
			if (j <= 0)
			{
				j = HashSlots - 1;
			}
			if (i == j)	//If these colide, then we have made a full search trough the table
			{
				break;
			}
		}
		return nullptr;
	}
	DataType* searchAllString(const uint32 Index, char* DataType::*Member, char* Value)
	{
		CoreNode *Checker = nullptr;
		for (int i = Index, j = Index; i < HashSlots; i++)
		{
			if (Data[i])
			{
				if (!memcmp(Data[i]->getData().*Member, Value, strlen(Value)))
				{
					return &Data[i]->getData();
				}
				else if (Data[i]->getNext())
				{
					Checker = Data[i]->getNext();
					do{
						if (!memcmp(Checker->getData().*Member, Value, strlen(Value)))
						{
							return &Checker->getData();
						}
						Checker = Checker->getNext();
					} while (Checker != nullptr);
				}
			}
			else if (Data[j])
			{
				if (!memcmp(Data[j]->getData().*Member, Value, strlen(Value)))
				{
					return &Data[j]->getData();
				}
				else if (Data[j]->getNext())
				{
					Checker = Data[j]->getNext();
					do{
						if (!memcmp(Checker->getData().*Member, Value, strlen(Value)))
						{
							return &Checker->getData();
						}
						Checker = Checker->getNext();
					} while (Checker != nullptr);
				}
			}
			j--;
			if (j <= 0)
			{
				j = HashSlots - 1;
			}
			if (i == j)
			{
				break;
			}
		}
		return nullptr;
	}

public:
	ClassHashTable(int Slots, HasherType Hasher) : HashTableBase<DataType, CoreNode>(Slots, Hasher) { };
	~ClassHashTable()
	{
		TableDestructor();
	}

	DataType* getDataFrom(void* Key, const uint32 ByteSize)
	{
		return Data[Indexer(Key, ByteSize)]->getClassDataPointer();
	}
	DataType* getDataFrom(void* Key, const uint32 ByteSize, uint32 NodeDepth)
	{
		return Data[Indexer(Key, ByteSize)]->getNode(NodeDepth)->getClassDataPointer();
	}
	DataType* getDataAt(uint32 Index)
	{
		return Data[Index]->getClassDataPointer();
	}
	DataType* getDataAt(uint32 Index, uint32 NodeDepth)
	{
		return Data[Index]->getNode(NodeDepth)->getClassDataPointer();
	}

	//Since we are dealing with classes here, we gonna ask a pointer to member as one of the possible overloads
	//This one is unique for a Class Hash Table
	template <class Type>
	DataType* findData(void* Key, const uint32 ByteSize, const Type DataType::*Member, Type Value)
	{
		uint32 Index = Indexer(Key, ByteSize);
		//Now we search if 'Value' is equal to the value pointed by the member-pointer, or, the value of that member itself. Read this as:
		//The value of 'Value' IS equal to the value from the MEMBER pointed by 'Member', from the class GET from the NodeHandler 'getClassDataAddress()', which node is pointed by Data[i]? Phew, that's pretty confusing
		if (Data[Index] == nullptr)
		{
			return nullptr;
		}
		else if (Data[Index]->getData().*Member == Value)
		{
			return &Data[Index]->getData();
		}
		else if (Data[Index]->getNext() != nullptr)	//Searching for it trough the linked list nodes
		{
			CoreNode *Checker = Data[Index]->getNext();
			do{
				if (Checker->getData().*Member == Value)
				{
					return &Checker->getData();
				}
				Checker = Checker->getNext();
			} while (Checker != nullptr);
		}
		return nullptr;
	}
	//The same as 'findData' but will only return 'nullptr' if the data is not present in this table (full table search)
	template <class Type>
	DataType* searchData(void* Key, const uint32 ByteSize, const Type DataType::*Member, Type Value)
	{
		uint32 Index = Indexer(Key, ByteSize);
		//Now we search if 'Value' is equal to the value pointed by the member-pointer, or, the value of that member itself. Read this as:
		//The value of 'Value' IS equal to the value from the MEMBER pointed by 'Member', from the class GET from the NodeHandler 'getClassDataAddress()', which node is pointed by Data[i]? Phew, that's pretty confusing
		if (Data[Index] == nullptr)
		{
			return searchAll(Index, Member, Value);
		}
		else if (Data[Index]->getData().*Member == Value)
		{
			return &Data[Index]->getData();
		}
		else
		{
			return searchAll(Index, Member, Value);
		}
		//Data NOT found in this table
		return nullptr;
	}
	DataType* findDataString(void* Key, const uint32 ByteSize, char* DataType::*Member, char* Value)
	{
		uint32 Index = Indexer(Key, ByteSize);
		//Now we search if 'Value' is equal to the value pointed by the member-pointer, or, the value of that member itself. Read this as:
		//The value of 'Value' IS equal to the value from the MEMBER pointed by 'Member', from the class GET from the NodeHandler 'getClassDataAddress()', which node is pointed by Data[i]? Phew, that's pretty confusing
		if (Data[Index] == nullptr)
		{
			return nullptr;
		}
		else if (!memcmp(Data[Index]->getData().*Member, Value, strlen(Value)))
		{
			return &Data[Index]->getData();
		}
		else if (Data[Index]->getNext() != nullptr)	//Searching for it trough the linked list nodes
		{
			CoreNode *Checker = Data[Index]->getNext();
			do{
				if (!memcmp(Checker->getData().*Member, Value, strlen(Value)))
				{
					return &Checker->getData();
				}
				Checker = Checker->getNext();
			} while (Checker != nullptr);
		}
		return nullptr;
	}
	DataType* searchDataString(void* Key, const uint32 ByteSize, char* DataType::*Member, char* Value)
	{
		uint32 Index = Indexer(Key, ByteSize);
		if (Data[Index] == nullptr)
		{
			return searchAllString(Index, Member, Value);
		}
		else if (!memcmp(Data[Index]->getData().*Member, Value, strlen(Value)))
		{
			return &Data[Index]->getData();
		}
		else
		{
			return searchAllString(Index, Member, Value);
		}
		return nullptr;
	}

	template <class Type>
	HashItemAddress<DataType, CoreNode>& findAddressOf(void* Key, const uint32 ByteSize, const Type DataType::*Member, Type Value)
	{
		uint32 Index = Indexer(Key, ByteSize);
		//Now we search if 'Value' is equal to the value pointed by the member-pointer, or, the value of that member itself. Read this as:
		//The value of 'Value' IS equal to the value from the MEMBER pointed by 'Member', from the class GET from the NodeHandler 'getClassDataAddress()', which node is pointed by Data[i]? Phew, that's pretty confusing
		if (Data[Index] == nullptr)
		{
			return HashItemAddress<DataType, CoreNode>();
		}
		else if (Data[Index]->getData().*Member == Value)
		{
			return HashItemAddress<DataType, CoreNode>(Index, 0, nullptr);
		}
		else if (Data[Index]->getNext() != nullptr)	//Searching for it trough the linked list nodes
		{
			CoreNode *Checker = Data[Index]->getNext();
			do{
				if (Checker->getData().*Member == Value)
				{
					return HashItemAddress<DataType, CoreNode>(Index, CoreNode::countChainLengthBetween(Data[Index], Checker), Checker);
				}
				Checker = Checker->getNext();
			} while (Checker != nullptr);
		}
		return HashItemAddress<DataType>();
	}
	HashItemAddress<DataType, CoreNode>& findAddressOfString(void* Key, const uint32 ByteSize, char* DataType::*Member, char* Value)
	{
		uint32 Index = Indexer(Key, ByteSize);
		//Now we search if 'Value' is equal to the value pointed by the member-pointer, or, the value of that member itself. Read this as:
		//The value of 'Value' IS equal to the value from the MEMBER pointed by 'Member', from the class GET from the NodeHandler 'getClassDataAddress()', which node is pointed by Data[i]? Phew, that's pretty confusing
		if (Data[Index] == nullptr)
		{
			return HashItemAddress<DataType, CoreNode>();
		}
		else if (!memcmp(Data[Index]->getData().*Member, Value, strlen(Value)))
		{
			return HashItemAddress<DataType, CoreNode>(Index, 0, nullptr);
		}
		else if (Data[Index]->getNext() != nullptr)	//Searching for it trough the linked list nodes
		{
			CoreNode *Checker = Data[Index]->getNext();
			do{
				if (!memcmp(Checker->getData().*Member, Value, strlen(Value)))
				{
					return HashItemAddress<DataType, CoreNode>(Index, CoreNode::countChainLengthBetween(Data[Index], Checker), Checker);
				}
				Checker = Checker->getNext();
			} while (Checker != nullptr);
		}
		return HashItemAddress<DataType, CoreNode>();
	}

#ifdef HASH_DEBUG
	template <class Type>
	void d_displayContentsDetailed(char* DataTypeName, const Type DataType::*EntryData)
	{
		uint32 ErrorMargin = 1;
		std::cout << "------------------ HASH TABLE CONTENTS [+] ------------------" << std::endl;
		std::cout << "[HASH] " << HashSlots << " Slots for data '" << DataTypeName << "' with size of " << sizeof(DataType) << "B each with a total of " << sizeof(CoreNode) << "B (Noded)" << std::endl;
		std::cout << "[HASH] Currently have " << countEntriesSimple() << "/" << HashSlots << " (" << HashSlots - countEntriesSimple() << " Free) entries in use (" << countEntriesFull() << " entries with nodes) using " << sizeof(CoreNode) * countEntriesFull() << "B(" << (sizeof(CoreNode) * countEntriesFull()) / 1024 << "KB)" << std::endl;
		std::cout << "[HASH] Theorical Clusterization: " << computeClusterization() << " (" << computeClusterization() * 100 << "%)" << std::endl;
		std::cout << "[HASH] Theorical Distribution Faults: " << computeHasherDistributionFaults(ErrorMargin) << " (" << computeHasherDistributionFaults(ErrorMargin) * 100 << "%) with Error Margin of " << ErrorMargin << std::endl;
		std::cout << "(P) -> Previous CoreNode | (C) -> Current CoreNode | (N) -> Next CoreNode" << std::endl;
		for (int i = 0; i < HashSlots; i++)
		{
			std::cout << " *[" << i << "] - ";
			if (Data[i] == nullptr)
			{
				std::cout << "<|> NULL <|>" << std::endl;
			}
			else
			{
				int ChainLength = Data[i]->countChainLengthFrom(Data[i]);
				if (ChainLength == 1)
				{
					std::cout << "(Single Entry) [" << Data[i]->getClassDataPointer() << "]" << std::endl;
					std::cout << "\t*[Entry Data] -> [" << Data[i]->getData().*EntryData << "]" << std::endl;
				}
				else
				{
					std::cout << "{Nested Entry} (" << ChainLength << " Nodes)" << std::endl;
					CoreNode *Checker = Data[i];
					int NodeDepth = 0;
					while (Checker != nullptr)
					{
						std::cout << "\t>[" << i << "." << NodeDepth << "] - (P)[" << Checker->getPrevious()->getClassDataPointer() << "] (C)[" << Checker->getClassDataPointer() << "] (N)[" << Checker->getNext()->getClassDataPointer() << "]" << std::endl;
						std::cout << "\t\t*[Entry Data] -> [" << Checker->getData().*EntryData << "]" << std::endl;
						Checker = Checker->getNext();
						NodeDepth++;
					}
				}
			}
		}
		if (countEntriesFull() >= 50)
		{
			std::cout << "------------------ END OF ENTRIES ------------------" << std::endl;
			std::cout << "[HASH] " << HashSlots << " Slots for data '" << DataTypeName << "' with size of " << sizeof(DataType) << "B each with a total of " << sizeof(CoreNode) << "B (Noded)" << std::endl;
			std::cout << "[HASH] Currently have " << countEntriesSimple() << "/" << HashSlots << " (" << HashSlots - countEntriesSimple() << " Free) entries in use (" << countEntriesFull() << " entries with nodes) using " << sizeof(CoreNode) * countEntriesFull() << "B(" << (sizeof(CoreNode) * countEntriesFull()) / 1024 << "KB)" << std::endl;
			std::cout << "[HASH] Clusterization: " << computeClusterization() << " (" << computeClusterization() * 100 << "%) " << std::endl;
			std::cout << "[HASH] Distribution Faults: " << computeHasherDistributionFaults(ErrorMargin) << " (" << computeHasherDistributionFaults(ErrorMargin) * 100 << "%) with Error Margin of " << ErrorMargin << std::endl;
		}
		std::cout << "------------------ HASH TABLE DEBG END [+] ------------------" << std::endl;
	}
	template <class Type>
	void d_displayContentsDetailed(char* DataTypeName, const Type DataType::*EntryData, const char* EntryName)
	{
		uint32 ErrorMargin = 1;
		std::cout << "------------------ HASH TABLE CONTENTS [+] ------------------" << std::endl;
		std::cout << "[HASH] " << HashSlots << " Slots for data '" << DataTypeName << "' with size of " << sizeof(DataType) << "B each with a total of " << sizeof(CoreNode) << "B (Noded)" << std::endl;
		std::cout << "[HASH] Currently have " << countEntriesSimple() << "/" << HashSlots << " (" << HashSlots - countEntriesSimple() << " Free) entries in use (" << countEntriesFull() << " entries with nodes) using " << sizeof(CoreNode) * countEntriesFull() << "B(" << (sizeof(CoreNode) * countEntriesFull()) / 1024 << "KB)" << std::endl;
		std::cout << "[HASH] Theorical Clusterization: " << computeClusterization() << " (" << computeClusterization() * 100 << "%)" << std::endl;
		std::cout << "[HASH] Theorical Distribution Faults: " << computeHasherDistributionFaults(ErrorMargin) << " (" << computeHasherDistributionFaults(ErrorMargin) * 100 << "%) with Error Margin of " << ErrorMargin << std::endl;
		std::cout << "(P) -> Previous CoreNode | (C) -> Current CoreNode | (N) -> Next CoreNode" << std::endl;
		for (int i = 0; i < HashSlots; i++)
		{
			std::cout << " *[" << i << "] - ";
			if (Data[i] == nullptr)
			{
				std::cout << "<|> NULL <|>" << std::endl;
			}
			else
			{
				int ChainLength = Data[i]->countChainLengthFrom(Data[i]);
				if (ChainLength == 1)
				{
					std::cout << "(Single Entry) [" << Data[i]->getClassDataPointer() << "]" << std::endl;
					std::cout << "\t*[" << EntryName << "] -> [" << Data[i]->getClassDataAddress().*EntryData << "]" << std::endl;
				}
				else
				{
					std::cout << "{Nested Entry} (" << ChainLength << " Nodes)" << std::endl;
					CoreNode *Checker = Data[i];
					int NodeDepth = 0;
					while (Checker != nullptr)
					{
						std::cout << "\t>[" << i << "." << NodeDepth << "] - (P)[" << Checker->getPrevious()->getClassDataPointer() << "] (C)[" << Checker->getClassDataPointer() << "] (N)[" << Checker->getNext()->getClassDataPointer() << "]" << std::endl;
						std::cout << "\t\t*[" << EntryName << "] -> [" << Checker->getClassDataAddress().*EntryData << "]" << std::endl;
						Checker = Checker->getNext();
						NodeDepth++;
					}
				}
			}
		}
		if (countEntriesFull() >= 50)
		{
			std::cout << "------------------ END OF ENTRIES ------------------" << std::endl;
			std::cout << "[HASH] " << HashSlots << " Slots for data '" << DataTypeName << "' with size of " << sizeof(DataType) << "B each with a total of " << sizeof(CoreNode) << "B (Noded)" << std::endl;
			std::cout << "[HASH] Currently have " << countEntriesSimple() << "/" << HashSlots << " (" << HashSlots - countEntriesSimple() << " Free) entries in use (" << countEntriesFull() << " entries with nodes) using " << sizeof(CoreNode) * countEntriesFull() << "B(" << (sizeof(CoreNode) * countEntriesFull()) / 1024 << "KB)" << std::endl;
			std::cout << "[HASH] Clusterization: " << computeClusterization() << " (" << computeClusterization() * 100 << "%) " << std::endl;
			std::cout << "[HASH] Distribution Faults: " << computeHasherDistributionFaults(ErrorMargin) << " (" << computeHasherDistributionFaults(ErrorMargin) * 100 << "%) with Error Margin of " << ErrorMargin << std::endl;
		}
		std::cout << "------------------ HASH TABLE DEBG END [+] ------------------" << std::endl;
	}
	void d_displayContentsDetailed(char* DataTypeName, char** IndexLabel, uint32 Labels)
	{
		uint32 ErrorMargin = 1;
		std::cout << "------------------ HASH TABLE CONTENTS [+] ------------------" << std::endl;
		std::cout << "[HASH] " << HashSlots << " Slots for data '" << DataTypeName << "' with size of " << sizeof(DataType) << "B each with a total of " << sizeof(CoreNode) << "B (Noded)" << std::endl;
		std::cout << "[HASH] Currently have " << countEntriesSimple() << "/" << HashSlots << " (" << HashSlots - countEntriesSimple() << " Free) entries in use (" << countEntriesFull() << " entries with nodes) using " << sizeof(CoreNode) * countEntriesFull() << "B(" << (sizeof(CoreNode) * countEntriesFull()) / 1024 << "KB)" << std::endl;
		std::cout << "[HASH] Theorical Clusterization: " << computeClusterization() << " (" << computeClusterization() * 100 << "%)" << std::endl;
		std::cout << "[HASH] Theorical Distribution Faults: " << computeHasherDistributionFaults(ErrorMargin) << " (" << computeHasherDistributionFaults(ErrorMargin) * 100 << "%) with Error Margin of " << ErrorMargin << std::endl;
		std::cout << "(P) -> Previous CoreNode | (C) -> Current CoreNode | (N) -> Next CoreNode" << std::endl;
		for (int i = 0, lbl = 0; i < HashSlots; i++)
		{
			std::cout << " *[" << i << "] - ";
			if (Data[i] == nullptr)
			{
				std::cout << "<|> NULL <|>" << std::endl;
			}
			else
			{
				int ChainLength = Data[i]->countChainLengthFrom(Data[i]);
				if (ChainLength == 1)
				{
					std::cout << "(Single Entry) [" << Data[i]->getClassDataPointer() << "] | [" << IndexLabel[lbl] << "]" << std::endl;
				}
				else
				{
					std::cout << "{Nested Entry} (" << ChainLength << " Nodes) | [" << IndexLabel[lbl] << "]" << std::endl;
					CoreNode *Checker = Data[i];
					int NodeDepth = 0;
					while (Checker != nullptr)
					{
						std::cout << "\t>[" << i << "." << NodeDepth << "] - (P)[" << Checker->getPrevious()->getClassDataPointer() << "] (C)[" << Checker->getClassDataPointer() << "] (N)[" << Checker->getNext()->getClassDataPointer() << "]" << std::endl;
						Checker = Checker->getNext();
						NodeDepth++;
					}
				}
			}
			if (i < Labels)
			{
				lbl++;
			}
		}
		if (countEntriesFull() >= 50)	//To ease data analysis when the Hash Table is too big
		{
			std::cout << "------------------ END OF ENTRIES ------------------" << std::endl;
			std::cout << "[HASH] " << HashSlots << " Slots for data '" << DataTypeName << "' with size of " << sizeof(DataType) << "B each with a total of " << sizeof(CoreNode) << "B (Noded)" << std::endl;
			std::cout << "[HASH] Currently have " << countEntriesSimple() << "/" << HashSlots << " (" << HashSlots - countEntriesSimple() << " Free) entries in use (" << countEntriesFull() << " entries with nodes) using " << sizeof(CoreNode) * countEntriesFull() << "B(" << (sizeof(CoreNode) * countEntriesFull()) / 1024 << "KB)" << std::endl;
			std::cout << "[HASH] Clusterization: " << this->computeClusterization() << " (" << this->computeClusterization() * 100 << "%) " << std::endl;
			std::cout << "[HASH] Distribution Faults: " << this->computeHasherDistributionFaults(ErrorMargin) << " (" << this->computeHasherDistributionFaults(ErrorMargin) * 100 << "%) with Error Margin of " << ErrorMargin << std::endl;
		}
		std::cout << "------------------ HASH TABLE DEBG END [+] ------------------" << std::endl;
	}
#endif
	
};

template <class DataType, class CoreNode>
class ClassHashTableSP : public ClassHashTable<DataType, CoreNode>
{
protected:
	uint32 FreeSlots;
	uint32 *ChainDepth;
	CoreNode **LastNode;

public:
	ClassHashTableSP(int Slots, HasherType Hasher) : ClassHashTable<DataType, CoreNode>(Slots, Hasher) 
	{ 
		FreeSlots = HashSlots;
		LastNode = new CoreNode*[HashSlots];
		ChainDepth = new uint32[HashSlots];
		for (uint32 i = 0; i < HashSlots; i++)
		{
			LastNode[i] = nullptr;
			ChainDepth[i] = 0;
		}
	};
	~ClassHashTableSP()
	{
		TableDestructor();
		delete[] LastNode;
		LastNode = nullptr;
		delete[] ChainDepth;
		ChainDepth = nullptr;
	}

	void insertData(DataType &DataToInsert)
	{
		uint32 Index = Indexer(&DataToInsert, sizeof(DataType));
		if (Data[Index])	//The slot is not pointing to a null position. This means it's occupied
		{
			//Since 'Data' is a linked list, we can simply add a node after it
			LastNode[Index] = Data[Index]->addNodeAfterOf(LastNode[Index], DataToInsert);
			ChainDepth[Index]++;
		}
		else
		{
			Data[Index] = new CoreNode;
			Data[Index]->setData(DataToInsert);
			LastNode[Index] = Data[Index];
			FreeSlots--;
		}
	}
	//Uses a given 'Key' as a key and insert 'DataToInsert', deducting that 'Key' is of type 'DataType', using it's size to compute the key
	void insertData(DataType &DataToInsert, const void* Key)
	{
		uint32 Index = Indexer(Key, sizeof(DataType));
		if (Data[Index])
		{
			LastNode[Index] = Data[Index]->addNodeAfterOf(LastNode[Index], DataToInsert);
			ChainDepth[Index]++;
		}
		else
		{
			Data[Index] = new CoreNode;
			Data[Index]->setData(DataToInsert);
			LastNode[Index] = Data[Index];
			FreeSlots--;
		}
	}
	//Uses a given 'Key' as a key, insert 'DataToInsert' and requires a 'ByteSize' to the actual size of 'Key'. Use this if the key given isn't of type 'DataType'
	void insertData(DataType &DataToInsert, const void* Key, uint32 ByteSize)
	{
		uint32 Index = Indexer(Key, ByteSize);
		if (Data[Index])
		{
			LastNode[Index] = Data[Index]->addNodeAfterOf(LastNode[Index], DataToInsert);
			ChainDepth[Index]++;
		}
		else
		{
			Data[Index] = new CoreNode;
			Data[Index]->setData(DataToInsert);
			LastNode[Index] = Data[Index];
			FreeSlots--;
		}
	}
	void insertDataAt(DataType &DataToInsert, uint32 Index)
	{
		if (Index < HashSlots)
		{
			if (Data[Index])
			{
				LastNode[Index] = Data[Index]->addNodeAfterOf(LastNode[Index], DataToInsert);
				ChainDepth[Index]++;
			}
			else
			{
				Data[Index] = new CoreNode;
				Data[Index]->setData(DataToInsert);
				LastNode[Index] = Data[Index];
				FreeSlots--;
			}
		}
	}

	virtual void clearIndex(uint32 Index)
	{
		if (Index < HashSlots)
		{
			if (Data[Index])
			{
				Data[Index]->deleteThisChain();	//Since there is no more node here, we don't need (actually we CANNOT) call "delete Data[Index]"
				Data[Index] = nullptr;
				FreeSlots++;
			}
		}
	}
};

#endif;	//Moon Wiz Hash Table Library